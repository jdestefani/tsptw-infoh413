%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------

% To have just one problem per page, simply put a \clearpage after each problem
\newpage
\begin{homeworkProblem}
\section{Simulated Annealing} \label{sa}
\subsection{Problem statement}
Implement two stochastic local search (SLS) algorithms for the traveling salesman problem with time windows (TPSTW), building on top of the perturbative local search methods from the first implementation exercise.
\begin{enumerate}
  \item Run each algorithm 25 times with different random seed on each instance. Instances will be available from http://iridia.ulb.ac.be/˜stuetzle/Teaching/HO/. As termination criterion, for each instance, use the maximum computation time it takes to run a full VND (implemented in the previous exercise) on the same instance and then multiply this time by 1000 (to allow for long enough runs of the SLS algorithms).
 \item Compute the following statistics for each of the two SLS algorithms and each instance:
 \begin{itemize}
   \item Percentage of runs with constraint violations
   \item Mean penalised relative percentage deviation
 \end{itemize}

\item Produce boxplots of penalised relative percentage deviation.
\item Determine, using statistical tests (in this case, the Wilcoxon test), whether there is a statistically significant difference between the quality of the solutions generated by the two algorithms.
\item Measure, for each of the implemented algorithms on 5 instances, the run-time distributions to reach sufficiently high quality solutions (e.g. best-known solutions available at http://iridia.ulb.ac.be/˜manuel/tsptw-instances\#instances).
Measure the run-time distributions across 25 repetitions using a cut-off time of 10 times the termination criterion above.
\item Produce a written report on the implementation exercise:
\begin{itemize}
  \item Please make sure that each implemented SLS algorithm is appropriately described and that the computational results are carefully interpreted. Justify also the choice of the parameter settings and the choice
of the iterative improvement algorithm for the hybrid SLS algorithm.
  \item Present the results as in the previous implementation exercise (tables, boxplots, statistical tests).
  \item Present graphically the results of the analysis of the run-time distributions.
  \item Interpret appropriately the results and make conclusions on the relative performance of the algorithms across all the benchmark instances studied.
\end{itemize}
\end{enumerate}

\subsection{Metric definitions}\label{subsec:metric}
For each algorithm $k$, applied on instance $i$, using different randomly generated seeds one have to compute:
\begin{itemize}
  \item Number of constraint violations
  \item Penalised relative percentage deviation (PRPD)
  \item Computation time (CPU time)
\end{itemize}

In order to perform a statistical analysis of the results, each algorithm $k$ is launched 100 times on the same instance, computing the
following statistics:
\begin{itemize}
  \item Percentage of infeasible solutions (0.x has to be interpreted as x\%) 
  \item Average Penalised relative percentage deviation.
  \item Average Computation time (CPU time).
\end{itemize}

For each instance $i$, the distributions of PRPD and Cpu Times are displayed using box plots and the Wilcoxon signed rank test is performed, in order to assess the existence of a statistically significant difference among the results obtained by the different algorithms on the same instance. 

\paragraph{Constraint Violations}
In the standard formulation of the TSP problem, a solution to the problem is represented by a permutation of the different
entities (solution components), that the hypothetical travelling salesman has to visit.

The best solution for the problem is the permutation that minimizes the total travelling time (distance) among the cities.
The presence of time windows introduce an additional constraint on the feasibility of the solution.

In fact, each solution component has an associated time window within which it has to be visited in order to guarantee the feasiblity of the tour.

Arriving in a (city) before the opening of the corresponding time window involves a delay in the total travelling time (to wait for the time window to open) whereas the arrival after the closure of the time windows will generate a constraint violation.

Thus, a solution is feasible if and only if all the time windows constraints are met, or in other words, if there are no constraint violations.

In this case, the best solution is the feasible solution which minimizes the total travel time.

\paragraph{Penalised Relative Percentage Deviation}
The penalised relative percentage deviation (PRDP from now on) is a measure of the solution quality, with respect to the best known
solution for the instance, taking into account a strong penalisation for the violation of constraints.
The PRPD is computed as follows:
\begin{equation}
pRPD_{kri} = 100 \cdot \frac{(f_{kri} + 10^4\cdot\Omega_{kri})-best_i}{best_i}
\end{equation}

\paragraph{Runtime}
The runtime is a measure of both the quality and the time complexity of the algorithm.

It is measured using the function \verb|int clock_gettime(clockid_t clk_id, struct timespect *tp)| from the \verb|time.h| library.

The parameter \verb|clk_id=CLOCK_PROCESS_CPUTIME_ID|, is used to read the values from an high-resolution timer provided by the CPU for each process.

The runtime is computed (using the user defined function \verb|ComputeRunTime|) as the difference, with a resolution of $10^-9$ s, from the time obtained using \verb|clock_gettime| at the beginning and the one obtained at the end of the simulation.

\subsection{Algorithm structure} \label{sec:algstrucSA}
\begin{algorithm}
\caption{Simulated Annealing TSPTW}
\label{SA:TSPTW}
\begin{algorithmic}
\Procedure{SimulatedAnnealing}{$\alpha,\chi_0,l,t_{\max},f_{best}$}    
  \Require Annealing schedule
  \State $s \gets$ \emph{InitialSolution}() \Comment{Heuristic or random permutation}
  \State $T \gets$ \emph{InitTemperature}() 
  \While{!\emph{TerminationCondition}($s,t_{\max},f_{best}$)}
    \State $s' \gets$ \emph{ProposalMechanism()} \Comment{(Often) Uniform random choice  in $N(s)$}
    \If{\emph{AcceptanceCriterion}($s,s',T$)} \Comment{(Often) Metropolis condition}
      \State $s \gets s'$
    \EndIf
  \State $T \gets$ \emph{Update}($T$) \Comment{$T_{i+1} = \alpha \cdot T_i$}
\EndWhile
  \State \textbf{return} $s$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{center}
  
\begin{minipage}{.45\textwidth}
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
                    semithick]
  \tikzstyle{every state}=[fill=blue!20,draw=none,thick]

  \node[initial,state]  (IS)                    {\emph{IS}};
  \node[state]          (SA) [right of=IS]      {\emph{SA}};
  \node[state,accepting](End)[below left of=SA] {$\Omega$};

  \path (IS) edge              node {DET} (SA)
        (SA) edge [loop above] node {CDET(not \emph{TC})} (SA)
             edge              node {CDET(\emph{TC})} (End);
\end{tikzpicture}
\end{minipage}%
\hspace{1.5cm}
\begin{minipage}{.45\textwidth}
\centering
\paragraph{Nodes}
\begin{itemize}
  \item \emph{IS} $\equiv$ \emph{InitialSolution}()
  \item \emph{SA} $\equiv$ \emph{SimulatedAnnealingLoop}
\end{itemize}
\paragraph{Conditions}
\begin{itemize}
  \item \emph{TC} $\equiv$ \emph{TerminationCondition}()
\end{itemize}
\end{minipage}
\captionof{figure}{Simulated Annealing GLSM}
\end{center}



\begin{algorithm}
\caption{Initial solution}
\label{SA:Init}
\begin{algorithmic}
\Procedure{Initial Solution}{}

\State $p \gets$ \emph{UniformRandom}($1,\frac{|N|}{10}$) \Comment{$p$ : Number of perturbations}
\State $s \gets$ \emph{SortCitiesUBTW}() \Comment{Sort nodes based on upper bound of time window}	

\While{$p > 0$}
  \State $p_p \gets$ \emph{UniformRandom}($1,|N|-1$) \Comment{$p_p$ : Perturbation point}
  \State $p_i \gets$ \emph{UniformRandom}($1,p$) \Comment{$p_i$ : Perturbation intensity}
  \State $s \gets$ \emph{Shuffle}($1+p_p,1+p_p+p_i$) \Comment{Shuffle the solution components occuping the position bounded by the indexes given as parameters}
  \State $p \gets p-1$
\EndWhile	

\State \textbf{return} $s$

\EndProcedure    
\end{algorithmic}
\end{algorithm}

\subsubsection{Termination condition}
\begin{algorithm}[!h]
  \caption{Termination Condition}\label{SA:Term}
  \begin{algorithmic}[1]
    \Procedure{TerminationCondintion}{$s,t_{\max},s_{best}$}
          \If{ $(f(s) = f_{best} \wedge \Omega(s) = 0) \vee  t > t_{\max} $}
				    \State \textbf{return true}
			    \EndIf
      \State \textbf{return false}
    \EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Proposal mechanism}
\label{SA:Prop}
\begin{algorithmic}
\Procedure{Proposal mechanism}{} 
  \State $i \gets $ \emph{UniformRandom}($1,|N|$)
  \While {$i = j$}
    \State $j \gets $ \emph{UniformRandom}($1,|N|$)
  \EndWhile  
  \State \textbf{return} \emph{InsertTourComponent}($s,i,j$)   
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Acceptance Criterion}
\label{saTSPTW}
\begin{algorithmic}
\Procedure{Acceptance criterion}{$s,s',T$}
\If {\emph{IsImproving}($s,s',t$)}
  \State \textbf{return} $1$
\Else
  \State \textbf{return} $e^{\frac{f(s)-f(s')}{T}}$
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\paragraph{Metropolis condition}
\begin{equation} \label{eq:metropolis}
  P(s,s',T) = \begin{cases}
               1 & f(s) < f(s') \\
               1 & f(s) = f(s') \wedge \Omega(s) < \Omega(s')\\
               e^{\frac{f(s)-f(s')}{T}} & \text{otherwise}
              \end{cases}
\end{equation}

\begin{algorithm}
\caption{Update temperature according to annealing schedule}
\label{saTSPTW}
\begin{algorithmic}
\Procedure{Update}{$T,l$}
  \If{iteration \% $l$}
    \State \textbf{return} $\alpha \cdot T$
  \Else
    \State \textbf{return} $T$
  \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Temperature initialization}
\label{saTInit}
\begin{algorithmic}
\Procedure{InitTemperature}{}
  \State $a \gets 0$
  \While($i < r$)
    \State $s_1 \gets$ \emph{RandomPermutation}()
    \State $s_2 \gets$ \emph{RandomPermutation}()
    \State $a \gets |f(s_1)-f(s_2)|$
    \State $i \gets i + 1$
  \EndWhile
  \State $\bar{f(s)} \gets \frac{a}{i+1}$
  \State \textbf{return} $\frac{\bar{f(s)}}{\ln(\frac{1}{\chi_0})}$
\EndProcedure
\end{algorithmic}
\end{algorithm}


\end{homeworkProblem}		
